/*******************************************************************
 * File:        BlockDevice
 * Purpose:     Constants for accessing the block driver interfaces
 * Author:      Chris Johns
 * Notes:       To add a new constant, please submit a MR on this file
 *              with the required change, otherwise there is no guarantee
 *              that values won't clash.
 ******************************************************************/
#ifndef BLOCKDEVICES_H
#define BLOCKDEVICES_H

#define BLOCKDEVICES_VERSION 150

#ifndef CMHG
#ifdef USE_LONG_LONG
// longlong.h defines USE_LONG_LONG itself
#undef USE_LONG_LONG
#include "longlong.h"
#define UINT64 ulonglong_t
#define BYTE unsigned char
#else
#include <stdint.h>
#define UINT64 uint64_t
#define BYTE uint8_t
#endif

// Invalid device id
#define DeviceId_Invalid 0

/* Flags understood in the device information block */
#define DeviceFlag_ReadOnly         (1u<<0)      /* Device cannot be written to */
#define DeviceFlag_CanEject         (1u<<1)      /* Supports the eject operation */
#define DeviceFlag_Debug            (1u<<31)     /* Debug enabled */
#define DeviceFlag_Valid            ((1u<<2)-1) | (1u<<31)  /* Mask of the valid device flags */

// The address of a block on a device
typedef UINT64 blockaddr_t;

// Device Types
typedef enum {
  BlockDevice_DeviceType_Unknown    = 0,
  BlockDevice_DeviceType_Controller = 1,
  BlockDevice_DeviceType_Drive      = 2,
  BlockDevice_DeviceType_Disc       = 3,
  BlockDevice_DeviceType_Partition  = 4,
  BlockDevice_DeviceType_Track      = 5,
  BlockDevice_DeviceType_Parent     = -1
} device_type_t;

// Interface Types
typedef enum {
    BlockDevice_InterfaceType_Unknown = 0,
    BlockDevice_InterfaceType_FDC     = 1,
    BlockDevice_InterfaceType_ST506   = 2,
    BlockDevice_InterfaceType_IDE     = 3,
    BlockDevice_InterfaceType_SATA    = 4,
    BlockDevice_InterfaceType_SCSI    = 5,
    BlockDevice_InterfaceType_NVMe    = 6,
    BlockDevice_InterfaceType_RAM     = 7,
    BlockDevice_InterfaceType_Parent  = -1
} interface_type_t;

// Connection Types
typedef enum {
    BlockDevice_ConnectionType_Unknown     = 0,
    BlockDevice_ConnectionType_Motherboard = 1,
    BlockDevice_ConnectionType_Podule      = 2,
    BlockDevice_ConnectionType_PCI         = 3,
    BlockDevice_ConnectionType_Parallel    = 4,
    BlockDevice_ConnectionType_Serial      = 5,
    BlockDevice_ConnectionType_USB         = 6,
    BlockDevice_ConnectionType_Parent      = -1
} connection_type_t;

// Media Types
typedef enum {
    BlockDevice_MediaType_Unknown  = 0,
    BlockDevice_MediaType_Floppy   = 1,
    BlockDevice_MediaType_HardDisc = 2,
    BlockDevice_MediaType_SSD      = 3,
    BlockDevice_MediaType_RAM      = 4,
    BlockDevice_MediaType_CD       = 5,
    BlockDevice_MediaType_DVD      = 6,
    BlockDevice_MediaType_BluRay   = 7,
    BlockDevice_MediaType_Parent   = -1
} media_type_t;

// Device Info
typedef struct device_info_s {
    char             *name;
    unsigned          flags;
    unsigned          parent_device;
    unsigned          device_index;
    blockaddr_t       block_count;
    unsigned          block_size;
    device_type_t     device_type;
    interface_type_t  interface_type;
    connection_type_t connection_type;
    media_type_t      media_type;
    char             *description;
} device_info_t;

// Used to control IO operations
typedef struct transfer_block_s {
  blockaddr_t  lba;
  void        *address; // Ignored for verify
  unsigned     count;   // In blocks
} transfer_block_t;

/* Reason codes for the driver */
#define BlockDevices_Reason_Read        1
#define BlockDevices_Reason_Write       2
#define BlockDevices_Reason_Verify      3
#define BlockDevices_Reason_DeviceOp    4
#define BlockDevices_Reason_MediaOp     5
#define BlockDevices_Reason_SecurityOp  6
#define BlockDevices_Reason_SectorOp    7
#define BlockDevices_Reason_DriverOp    8

/*******************************************************************
 * DeviceOps
 ******************************************************************/

/* Get serial, model or firmware.
 * Entry: None
 * Exit:  R0 -> Requested string
 */
#define BlockDevice_DeviceOp_SerialNumber 0x1
#define BlockDevice_DeviceOp_ModelName    0x2
#define BlockDevice_DeviceOp_Firmware     0x3

/* Read SMART status
 * Entry: R2 -> buffer for results
 *        R3  = size of buffer (in entries)
 *              or pass R3,R4 = 0 to get the size needed
 * Exit:  R3  = number of items returned
 * If the passed buffer isn't large enough, R3 will be set to the
 * required size, and an error genrated (unless R2 is NULL)
 */
#define BlockDevice_DeviceOp_SMART 0x4
typedef enum {
    BlockDevice_SMART_Status_OK       = 0,
    BlockDevice_SMART_Status_Warning  = 1,
    BlockDevice_SMART_Status_Critical = 2,
    BlockDevice_SMART_Status_Failure  = 3,
    BlockDevice_SMART_Status_Unknown  = -1
} smart_status_t;
/* Flags */
#define BlockDevice_SMART_Flags_DataSize_Mask     0x3
#define BlockDevice_SMART_Flags_DataSize_64       0x2
#define BlockDevice_SMART_Flags_DataSize_128      0x3
#define BlockDevice_SMART_Flags_Higher_Is_Better  0x4 // Setting both
#define BlockDevice_SMART_Flags_Lower_Is_Better   0x8 // is undefined

typedef enum {
    BlockDevice_SMART_Type_General = 0,
    BlockDevice_SMART_Type_IDE     = 1,
    BlockDevice_SMART_Type_SCSI    = 2,
    BlockDevice_SMART_Type_NVMe    = 3
} smart_type_t;

typedef struct {
  smart_status_t status;
  unsigned       flags;
  smart_type_t   type;
  unsigned       id;
  union {
    UINT64       value64;     // Data Size = 2
    BYTE         value128;    // Data Size = 3
    struct {
      unsigned   value;       // Data Size = 0
      unsigned   threshold;
      unsigned   critical;
      unsigned   spare;
    } words;
  } data;
} smart_attribute_t;

/* Self-test
 * Entry: R2 = Test type
 */
#define BlockDevice_DeviceOp_SelfTest 0x5
/* Test types */
typedef enum {
  BlockDevice_SelfTest_Short      = 1,
  BlockDevice_SelfTest_Long       = 2,
  BlockDevice_SelfTest_Conveyance = 3,
  BlockDevice_SelfTest_Extended   = 4,
  BlockDevice_SelfTest_Abort      = -1
} self_test_type_t;

/* Self-test log
 * Entry: R2 -> buffer for log entries
 *        R3 =  number of items to get
 */
#define BlockDevice_DeviceOp_SelfTestLog 0x6
/* Log item */
typedef enum {
  BlockDevice_SelfTest_Status_Completed = 0,
  BlockDevice_SelfTest_Status_Failed    = 1,
  BlockDevice_SelfTest_Status_Aborted   = 2,
  BlockDevice_SelfTest_Status_Running   = -2,
  BlockDevice_SelfTest_Status_Unknown   = -1
} self_test_result_status_t;

typedef struct self_test_result_s {
  self_test_result_status_t status;       // Status
  unsigned                  reason;       // Failure/Abort Reason
  unsigned                  percentage;   // Percentage complete
  unsigned                  segment;      // Segment
  self_test_type_t          test_type;    // Type of test
  interface_type_t          if_type;      // Interface type
  UINT64                    test_time;    // Time of test (all bits set for NA)
  UINT64                    fail_lba;     // Failing LBA (all bits set for NA)
  unsigned                  reserved[6];  //
} self_test_result_t;

/* Read partititon info
 * Entry: None
 * Exit:  R0 = Partition scheme
 *          MBR:
 *            R1  = Type
 *          GPT:
 *            R1 -> type GUID
 *            R2 -> partition GUID
 */
#define BlockDevice_DeviceOp_PartitionInfo 0x7
/* Partition Schemes */
typedef enum {
  BlockDevice_PartitionScheme_MBR = 1,
  BlockDevice_PartitionScheme_GPT = 2
} partiton_scheme_t;

/*******************************************************************
 * SectorOps
 ******************************************************************/
#define BlockDevice_SectorOp_TRIM 0x1

/* TRIM */
typedef struct trim_request_s {
  UINT64   start_lba; // Starting LBA
  unsigned count;     // Number of blocks to trim
} trim_request_t;

/*******************************************************************
 * MediaOps
 ******************************************************************/

/* Get block sizes
 * Entry: R2 -> Buffer for result
 *        R3  = index (0 to start)
 *        R4  = number of sizes to get
 * Exit:  R3  = index for next call
 *        R4  = number of sizes got
 */
#define BlockDevice_MediaOp_BlockSizes 0x2
/* BlockSizes */
typedef struct block_size_s {
  unsigned size;         // Block size, in bytes
  unsigned flags;        // Flags
  struct {
    signed  value;       // Relative priority
    char   *description; // Priority description (optional)
  } priority;
} block_size_t;

/* Set block size
 * Entry: R2 = new block size (in bytes)
 */
#define BlockDevice_MediaOp_SetBlockSize 0x3

/*******************************************************************
 * SecurityOps
 ******************************************************************/
#endif

// Service calls
#define Service_BlockDevices_Started       0x81200
#define Service_BlockDevices_Dying         0x81201
#define Service_BlockDevices_DeviceAdded   0x81202
#define Service_BlockDevices_DeviceRemoved 0x81203

// Error numbers
#define ErrorBase_BlockDevices   0x822300
#define ErrorNumber_NoSuchDevice 0x822300
#define ErrorNumber_DeviceInUse  0x822301

// SWI numbers
#ifndef BlockDevice_0
#define BlockDevice_0 0x5A6C0
#endif
#ifndef BlockDevice_Info
#define BlockDevice_Info 0x5A6C0
#define BlockDevice_Read 0x5A6C1
#define BlockDevice_Write 0x5A6C2
#define BlockDevice_Verify 0x5A6C3
#define BlockDevice_DeviceOp 0x5A6C4
#define BlockDevice_MediaOp 0x5A6C5
#define BlockDevice_SecurityOp 0x5A6C6
#define BlockDevice_SectorOp 0x5A6C7
#define BlockDevice_DriverOp 0x5A6C8
#define BlockDevice_Register 0x5A6D0
#define BlockDevice_Deregister 0x5A6D1
#define BlockDevice_Rescan 0x5A6D2
#define BlockDevice_Enumerate 0x5A6D3
#define BlockDevice_EnumerateChildren 0x5A6D4
#endif

#endif
