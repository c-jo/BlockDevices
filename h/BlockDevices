/*******************************************************************
 * File:        BlockDevice
 * Purpose:     Constants for accessing the block driver interfaces
 * Author:      Chris Johns
 * Notes:       To add a new constant, please submit a MR on this file
 *              with the required change, otherwise there is no guarantee
 *              that values won't clash.
 ******************************************************************/
#ifndef BLOCKDEVICES_H
#define BLOCKDEVICES_H

#define BLOCKDEVICES_VERSION 150

#ifndef CMHG
#ifdef USE_LONG_LONG
// longlong.h defines USE_LONG_LONG itself
#undef USE_LONG_LONG
#include "longlong.h"
#define UINT64 ulonglong_t
#else
#include <stdint.h>
#define UINT64 uint64_t
#endif

// Invalid device id
#define DeviceId_Invalid 0

/* Flags understood in the device information block */
#define DeviceFlag_ReadOnly         (1u<<0)      /* Device cannot be written to */
#define DeviceFlag_CanEject         (1u<<1)      /* Supports the eject operation */
#define DeviceFlag_Debug            (1u<<31)     /* Debug enabled */
#define DeviceFlag_Valid            ((1u<<2)-1) | (1u<<31)  /* Mask of the valid device flags */

// The address of a block on a device
typedef UINT64 blockaddr_t;

// Device Types
typedef enum device_type_e {
  BlockDevice_DeviceType_Unknown    = 0,
  BlockDevice_DeviceType_Controller = 1,
  BlockDevice_DeviceType_Drive      = 2,
  BlockDevice_DeviceType_Disc       = 3,
  BlockDevice_DeviceType_Partition  = 4,
  BlockDevice_DeviceType_Track      = 5,
  BlockDevice_DeviceType_Parent     = -1
} device_type_t;

// Interface Types
typedef enum interface_type_e {
    BlockDevice_InterfaceType_Unknown = 0,
    BlockDevice_InterfaceType_FDC     = 1,
    BlockDevice_InterfaceType_ST506   = 2,
    BlockDevice_InterfaceType_IDE     = 3,
    BlockDevice_InterfaceType_SATA    = 4,
    BlockDevice_InterfaceType_SCSI    = 5,
    BlockDevice_InterfaceType_NVMe    = 6,
    BlockDevice_InterfaceType_RAM     = 7,
    BlockDevice_InterfaceType_Parent  = -1
} interface_type_t;

// Connection Types
typedef enum interface_connection_type_e {
    BlockDevice_ConnectionType_Unknown     = 0,
    BlockDevice_ConnectionType_Motherboard = 1,
    BlockDevice_ConnectionType_Podule      = 2,
    BlockDevice_ConnectionType_PCI         = 3,
    BlockDevice_ConnectionType_Parallel    = 4,
    BlockDevice_ConnectionType_Serial      = 5,
    BlockDevice_ConnectionType_USB         = 6,
    BlockDevice_ConnectionType_Parent      = -1
} connection_type_t;

// Media Types
typedef enum media_type_e {
    BlockDevice_MediaType_Unknown  = 0,
    BlockDevice_MediaType_Floppy   = 1,
    BlockDevice_MediaType_HardDisc = 2,
    BlockDevice_MediaType_SSD      = 3,
    BlockDevice_MediaType_RAM      = 4,
    BlockDevice_MediaType_CD       = 5,
    BlockDevice_MediaType_DVD      = 6,
    BlockDevice_MediaType_BluRay   = 7,
    BlockDevice_MediaType_Parent   = -1
} media_type_t;

// Device Info
typedef struct device_info_s {
    char             *name;
    unsigned          flags;
    unsigned          parent_device;
    unsigned          device_index;
    blockaddr_t       block_count;
    unsigned          block_size;
    device_type_t     device_type;
    interface_type_t  interface_type;
    connection_type_t connection_type;
    media_type_t      media_type;
    char             *description;
} device_info_t;

// Used to control IO operations
typedef struct transfer_block_s {
  blockaddr_t  lba;
  void        *address; // Ignored for verify
  unsigned     count;   // In blocks
} transfer_block_t;

/* Reason codes for the driver */
#define BlockDevices_Reason_Read        1
#define BlockDevices_Reason_Write       2
#define BlockDevices_Reason_Verify      3
#define BlockDevices_Reason_DeviceOp    4
#define BlockDevices_Reason_MediaOp     5
#define BlockDevices_Reason_SecurityOp  6
#define BlockDevices_Reason_SectorOp    7
#define BlockDevices_Reason_DriverOp    8

/*
 * DeviceOps
 */
#define BlockDevice_DeviceOp_SerialNumber  1
#define BlockDevice_DeviceOp_ModelName     2
#define BlockDevice_DeviceOp_Firmware      3
#define BlockDevice_DeviceOp_SMART         4
#define BlockDevice_DeviceOp_PartitionInfo 5
#define BlockDevice_DeviceOp_SelfTestLog   6
#define BlockDevice_DeviceOp_SelfTest      7

/* SMART */
#define BlockDevice_DeviceOp_SMART_Flag_Raw 0x01

typedef struct smart_attribute_header_s {
  unsigned status:8;
  unsigned flags:16;
  unsigned value_size:8;
  unsigned reserved:8;
  unsigned attribute_type:8;
  unsigned attribute_id:16;
} smart_attribute_header_t;

#define BlockDevice_SMART_Attribute_Status_OK       0x00
#define BlockDevice_SMART_Attribute_Status_Warning  0x01
#define BlockDevice_SMART_Attribute_Status_Critical 0x02
#define BlockDevice_SMART_Attribute_Status_Failure  0x03

#define BlockDevice_SMART_Attribute_Flags_Threshold_Present 1
#define BlockDevice_SMART_Attribute_Flags_Critical_Present  2
#define BlockDevice_SMART_Attribute_Flags_Higher_Is_Better  4 // Setting both
#define BlockDevice_SMART_Attribute_Flags_Lower_Is_Better   8 // is undefined

#define BlockDevice_SMART_Attribute_Type_General 0x00
#define BlockDevice_SMART_Attribute_Type_IDE     0x01
#define BlockDevice_SMART_Attribute_Type_SCSI    0x02
#define BlockDevice_SMART_Attribute_Type_NVMe    0x03

/* Partition Types */
#define BlockDevice_PartitionType_MBR 1
#define BlockDevice_PartitionType_GPT 2

/* Self-Test */
#define BlockDevice_SelfTest_Status_Completed  0x00
#define BlockDevice_SelfTest_Status_Failed     0x01
#define BlockDevice_SelfTest_Status_Aborted    0x02
#define BlockDevice_SelfTest_Status_Running    0x80
#define BlockDevice_SelfTest_Status_Unknown    0xff

typedef enum {
  BlockDevice_SelfTest_Short      = 1,
  BlockDevice_SelfTest_Long       = 2,
  BlockDevice_SelfTest_Conveyance = 3,
  BlockDevice_SelfTest_Extended   = 4,
  BlockDevice_SelfTest_Abort      = -1,
} test_type_t;

typedef __packed struct self_test_result_s {
  uint8_t          status;       // Status
  uint8_t          reason;       // Failure/Abort Reason
  uint8_t          percentage;   // Percentage complete
  uint8_t          segment;      // Segment
  test_type_t      test_type;    // Type of test
  interface_type_t if_type;      // Interface type
  uint64_t         test_time;    // Time of test (0xffffffffffffffff if NA)
  uint64_t         fail_lba;     // Failing LBA  (0xffffffffffffffff if NA)
  uint32_t         reserved[6];  //
} self_test_result_t;

#define BlockDevice_DeviceOp_SelfTestLog_Flag_Raw 0x1

/*
 * SectorOps
 */
#define BlockDevice_SectorOp_TRIM 1

/* TRIM */
typedef struct trim_request_s {
  uint64_t start_lba; // Starting LBA
  uint32_t count;     // Number of blocks to trim
} trim_request_t;

/*
 * MediaOps
 */
#define BlockDevice_MediaOp_BlockSizes   1
#define BlockDevice_MediaOp_SetBlockSize 2

/* BlockSizes */
typedef struct block_size_s {
  unsigned size;         // Block size, in bytes
  unsigned flags;        // Flags
  struct {
    signed  value;       // Relative priority
    char   *description; // Priority description (optional)
  } priority;
} block_size_t;

/*
 * SecurityOps
 */

#endif

// Service calls
#define Service_BlockDevices_Started       0x81200
#define Service_BlockDevices_Dying         0x81201
#define Service_BlockDevices_DeviceAdded   0x81202
#define Service_BlockDevices_DeviceRemoved 0x81203

// Error numbers
#define ErrorBase_BlockDevices   0x822300
#define ErrorNumber_NoSuchDevice 0x822300
#define ErrorNumber_DeviceInUse  0x822301

// SWI numbers
#ifndef BlockDevice_0
#define BlockDevice_0 0x5A6C0
#endif
#ifndef BlockDevice_Info
#define BlockDevice_Info 0x5A6C0
#define BlockDevice_Read 0x5A6C1
#define BlockDevice_Write 0x5A6C2
#define BlockDevice_Verify 0x5A6C3
#define BlockDevice_DeviceOp 0x5A6C4
#define BlockDevice_MediaOp 0x5A6C5
#define BlockDevice_SecurityOp 0x5A6C6
#define BlockDevice_SectorOp 0x5A6C7
#define BlockDevice_DriverOp 0x5A6C8
#define BlockDevice_Register 0x5A6D0
#define BlockDevice_Deregister 0x5A6D1
#define BlockDevice_Rescan 0x5A6D2
#define BlockDevice_Enumerate 0x5A6D3
#define BlockDevice_EnumerateChildren 0x5A6D4
#endif

#endif
