/*******************************************************************
 * File:        device
 * Purpose:     Management of a single device and its interfaces
 * Author:      Chris Johns
 ******************************************************************/

#include <stdlib.h>
#include <string.h>

#include "callx.h"
#ifdef FORTIFY
#include "fortify.h"
#endif
#include "BlockDevicesHdr.h"
#include "BlockDevices.h"
#include "device.h"
#include "devices.h"
#include "str.h"

#ifndef PYRO
#include "DebugLib/DebugLib.h"
#else
#define dprintf(X) ;
#endif

#include <stdio.h>

static struct name_counter_s {
    char *base_name;
    unsigned parent_device;
    int counter;
    struct name_counter_s *next;
} *name_counters = 0;

/*******************************************************************
 Function:      device_name
 Description:   Generate a device name for the given device
 Parameters:    info -> the device information block
 Returns:       pointer to device name string.
 ******************************************************************/
static char *device_name(const device_info_t *info)
{
    int sequence_number = info->device_index;
    char *name = NULL;

    if (!info || !info->name)
        return NULL;

    if (sequence_number == 0)
    {
      /* Index not specified, find counter entry for this name/parent device */
      struct name_counter_s *counter_entry = name_counters;
      while (counter_entry)
      {
          if (strcmp(counter_entry->base_name, info->name) == 0 &&
              counter_entry->parent_device == info->parent_device)
              break;
          counter_entry = counter_entry->next;
      }

      if (!counter_entry)
      {
          /* Create new counter entry */
          counter_entry = malloc(sizeof(struct name_counter_s));
          if (!counter_entry)
              return NULL;

          counter_entry->base_name = malloc(strlen(info->name) + 1);
          if (!counter_entry->base_name)
          {
              free(counter_entry);
              return NULL;
          }
          strcpy(counter_entry->base_name, info->name);
          counter_entry->parent_device = info->parent_device;
          counter_entry->counter = 1;
          counter_entry->next = name_counters;
          name_counters = counter_entry;
      }

      sequence_number = counter_entry->counter++;
    }

    name = malloc(strlen(info->name) + 16);

    /* Generate the device name */
    if (name) {
      sprintf(name, "%s-%d", info->name, sequence_number);
    }
    return name;
}

/*******************************************************************
 Function:      device_create
 Description:   Create a reference to a device
 Parameters:    info -> information about the device
                capabilities = capabilities flags
                driver_code -> the code to call for the driver
                driver_ws -> r12 value for the driver
                driver_ref -> reference to pass to the driver in R9
 Returns:       pointer to the device_t, or NULL if failed
 ******************************************************************/
device_t *device_create(
              device_info_t *info,
              void          *driver_code,
              void          *driver_ws,
              void          *driver_ref)
{
    device_t *device, *parent;

    device = calloc(1, sizeof(*device));
    if (device == NULL)
        return NULL;

    parent = devices_find(info->parent_device);

    dprintf(("", "creating device '%s' (parent: %d [%p])\n",
                 info->description, info->parent_device, (void*)parent));

    if (info->device_type == BlockDevice_DeviceType_Parent) {
      if (!parent) return NULL;
      dprintf(("", "use pareent device type (%d)\n", parent->info.device_type));
      device->info.device_type = parent->info.device_type;
    }
    else {
      dprintf(("", "device type: %d\n", info->device_type));
      device->info.device_type = info->device_type;
    }

    if (info->interface_type == BlockDevice_InterfaceType_Parent) {
      if (!parent) return NULL;
      dprintf(("", "use parent interface type (%d)\n", parent->info.interface_type));
      device->info.interface_type = parent->info.interface_type;
    }
    else {
      dprintf(("", "interface type: %d\n", info->interface_type));
      device->info.interface_type = info->interface_type;
    }

    if (info->connection_type == BlockDevice_ConnectionType_Parent) {
      if (!parent) return NULL;
      dprintf(("", "use parent connection type (%d)\n", parent->info.connection_type));
      device->info.connection_type = parent->info.connection_type;
    }
    else {
      dprintf(("", "connecion type: %d\n", info->connection_type));
      device->info.connection_type = info->connection_type;
    }

    if (info->media_type == BlockDevice_MediaType_Parent) {
      if (!parent) return NULL;
      dprintf(("", "use parent media type (%d)\n", parent->info.media_type));
      device->info.media_type = parent->info.media_type;
    }
    else {
      dprintf(("", "media_type: %d\n", info->media_type));
      device->info.media_type = info->media_type;
    }

    device->info.name        = device_name(info);
    device->info.description = strdup(info->description);

    /* Check the strings are valid */
    if (device->info.name == NULL || device->info.description == NULL) {
        free(device->info.name);
        free(device->info.description);
        free(device);
        return NULL;
    }

    device->info.flags           = info->flags;

    device->info.parent_device   = info->parent_device;
    device->info.device_index    = info->device_index;
    device->info.block_count     = info->block_count;
    device->info.block_size      = info->block_size;

    device->driver_code = driver_code;
    device->driver_ws   = driver_ws;
    device->driver_ref  = driver_ref;

    return device;
}

/*******************************************************************
 Function:      device_check_transfer
 Description:   Check whether a transfer would be valid
 Parameters:    device-> the device we're operating on
                transfer = the transfer address
 Returns:       pointer to error to return, or NULL if operation is acceptable
 ******************************************************************/
static _kernel_oserror *device_check_transfer(device_t *device, transfer_block_t *transfer)
{
 #ifdef USE_LONG_LONG
    blockaddr_t transfer_end;
    int blocks_count;
    blockaddr_t blocks_count_ll;

    blocks_count = (transfer->count + device->info.block_size - 1) / device->info.block_size;

    LL_UI2L(blocks_count_ll, blocks_count);
    LL_ADD(transfer_end, transfer->lba, blocks_count_ll);
    if (LL_UCMP(transfer_end, >, device->info.block_count))
#else
    blockaddr_t transfer_end = transfer->lba + transfer->count;

    if (transfer_end > device->info.block_count)
#endif
    {
        return err_TransferOutsideDevice;
    }

    return NULL;
}

/*******************************************************************
 Function:      device_destroy
 Description:   Destroy the device
 Parameters:    device-> the device we're destroying (assumed to already have
                      been unlinked).
 Returns:       none
 ******************************************************************/
void device_destroy(device_t *device)
{
    if (device)
    {
//        device->info.manufacturer = NULL;
//        free(device->info.manufacturer);
//        device->info.manufacturer = NULL;
//        free(device->info.product);
//        device->info.product = NULL;
//        free(device->info.serial);
//        device->info.serial = NULL;
//        free(device->info.firmware);
//        device->info.firmware = NULL;
        free(device->info.name);
        free(device->info.description);
        free(device);
    }
}


/*******************************************************************
 Function:      device_transfer
 Description:   Transfer data to or from a device.
 Parameters:    device -> the device to write to
                entry = driver entry to call
                flags = transfer flags
                block -> transfer block
 Returns:       pointer to an error block if failed
                NULL if successful
 ******************************************************************/
_kernel_oserror * device_transfer(device_t *device, unsigned int entry, unsigned long flags, transfer_block_t *block)
{
    _kernel_oserror *err;

    err = device_check_transfer(device, block);
    if (err)
        return err;

    return _callx(device->driver_code, device->driver_ws,
                  _INR(0, 2) | _INR(8, 9),
                  device->id, flags, block,
                  entry, device->driver_ref);
}


/*******************************************************************
 Function:      device_miscop
 Description:   Perform miscellaneous operations on the device
 Parameters:    device -> the device
                entry = driver entry to call
                r -> registers for operation
 Returns:       pointer to an error block if failed
                NULL if successful
 ******************************************************************/
_kernel_oserror * device_miscop(device_t *device, unsigned int entry, _kernel_swi_regs *r)
{
    // printf("device_miscop %d. dev id=%d r0=%d\n", entry, device->device_id, r->r[0]);
    return _callx(device->driver_code, device->driver_ws,
                  _INR(0, 9) | _OUTR(0, 7),
                  r->r[0], r->r[1], r->r[2], r->r[3],
                  r->r[4], r->r[5], r->r[6], r->r[7],
                  entry, device->driver_ref,
                  &r->r[0], &r->r[1], &r->r[2], &r->r[3],
                  &r->r[4], &r->r[5], &r->r[6], &r->r[7]
                  );
}
