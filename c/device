/*******************************************************************
 * File:        device
 * Purpose:     Management of a single device and its interfaces
 * Author:      Chris Johns
 ******************************************************************/

#include <stdlib.h>
#include <string.h>

#include "callx.h"
#ifdef FORTIFY
#include "fortify.h"
#endif
#include "BlockDevicesHdr.h"
#include "BlockDevices.h"
#include "device.h"
#include "devices.h"
#include "str.h"

#include <stdio.h>

static struct name_counter_s {
    char *base_name;
    unsigned parent_device;
    int counter;
    struct name_counter_s *next;
} *name_counters = 0;

/*******************************************************************
 Function:      device_name
 Description:   Generate a device name for the given device
 Parameters:    base_name -> the base name to use for generation
                parent_device_id -> the parent device ID
 Returns:       pointer to allocated device name string, or NULL if failed
 ******************************************************************/
static char *device_name(const char *base_name, unsigned parent_device_id)
{
    char *name_buffer;
    struct name_counter_s *counter_entry = NULL;
    int sequence_number = 1;
    int len;

    if (!base_name)
        return NULL;

    len = strlen(base_name);

    /* Check if name already ends with a number */
    if (len > 0 && base_name[len - 1] >= '0' && base_name[len - 1] <= '9')
    {
        /* Name already ends with a number, use it as is */
        name_buffer = malloc(len + 1);
        if (name_buffer)
            strcpy(name_buffer, base_name);
        return name_buffer;
    }

    /* Find counter entry for this base name and parent device */
    counter_entry = name_counters;
    while (counter_entry)
    {
        if (strcmp(counter_entry->base_name, base_name) == 0 &&
            counter_entry->parent_device == parent_device_id)
            break;
        counter_entry = counter_entry->next;
    }

    if (!counter_entry)
    {
        /* Create new counter entry */
        counter_entry = malloc(sizeof(struct name_counter_s));
        if (!counter_entry)
            return NULL;

        counter_entry->base_name = malloc(strlen(base_name) + 1);
        if (!counter_entry->base_name)
        {
            free(counter_entry);
            return NULL;
        }
        strcpy(counter_entry->base_name, base_name);
        counter_entry->parent_device = parent_device_id;
        counter_entry->counter = 1;
        counter_entry->next = name_counters;
        name_counters = counter_entry;
    }

    sequence_number = counter_entry->counter++;

    /* Allocate buffer for the generated name */
    name_buffer = malloc(strlen(base_name) + 16); /* Extra space for sequence number */
    if (!name_buffer)
        return NULL;

    /* Generate the device name */
    sprintf(name_buffer, "%s%d", base_name, sequence_number);

    return name_buffer;
}

/*******************************************************************
 Function:      device_create
 Description:   Create a reference to a device
 Parameters:    info -> information about the device
                capabilities = capabilities flags
                driver_code -> the code to call for the driver
                driver_ws -> r12 value for the driver
                driver_ref -> reference to pass to the driver in R9
 Returns:       pointer to the device_t, or NULL if failed
 ******************************************************************/
device_t *device_create(
              device_info_t * info,
              void *          driver_code,
              void *          driver_ws,
              void *          driver_ref)
{
    device_t *device;

    device = calloc(1, sizeof(*device));
    if (device == NULL)
        return NULL;

    device->driver_code = driver_code;
    device->driver_ws   = driver_ws;
    device->driver_ref  = driver_ref;

    device->info.name                 = device_name(info->name,
                                                    info->parent_device);
    device->info.flags                = info->flags;
    device->info.interface_type       = info->interface_type;
    device->info.interface_connection = info->interface_connection;
    device->info.media_type           = info->media_type;
    device->info.parent_device        = info->parent_device;
    device->info.block_count          = info->block_count;
    device->info.block_size           = info->block_size;
    device->info.description          = strdup(info->description);

    /* Check the strings are valid */
    if (device->info.name == NULL || device->info.description == NULL) {
        free(device->info.name);
        free(device->info.description);
        free(device);
        return NULL;
    }

    return device;
}

/*******************************************************************
 Function:      device_check_transfer
 Description:   Check whether a transfer would be valid
 Parameters:    device-> the device we're operating on
                transfer = the transfer address
 Returns:       pointer to error to return, or NULL if operation is acceptable
 ******************************************************************/
static _kernel_oserror *device_check_transfer(device_t *device, transfer_block_t *transfer)
{
 #ifdef USE_LONG_LONG
    blockaddr_t transfer_end;
    int blocks_count;
    blockaddr_t blocks_count_ll;

    blocks_count = (transfer->count + device->info.block_size - 1) / device->info.block_size;

    LL_UI2L(blocks_count_ll, blocks_count);
    LL_ADD(transfer_end, transfer->lba, blocks_count_ll);
    if (LL_UCMP(transfer_end, >, device->info.block_count))
#else
    blockaddr_t transfer_end = transfer->lba + transfer->count;

    if (transfer_end > device->info.block_count)
#endif
    {
        return err_TransferOutsideDevice;
    }

    return NULL;
}

/*******************************************************************
 Function:      device_destroy
 Description:   Destroy the device
 Parameters:    device-> the device we're destroying (assumed to already have
                      been unlinked).
 Returns:       none
 ******************************************************************/
void device_destroy(device_t *device)
{
    if (device)
    {
      free(device->info.name);
      device->info.name = NULL;
      free(device->info.description);
      device->info.description = NULL;
      free(device);
    }
}

/*******************************************************************
 Function:      device_transfer
 Description:   Transfer data to or from a device.
 Parameters:    device -> the device to write to
                entry = driver entry to call
                flags = transfer flags
                block -> transfer block
 Returns:       pointer to an error block if failed
                NULL if successful
 ******************************************************************/
_kernel_oserror * device_transfer(device_t *device, unsigned int entry, unsigned long flags, transfer_block_t *block)
{
    _kernel_oserror *err;

    err = device_check_transfer(device, block);
    if (err)
        return err;

    return _callx(device->driver_code, device->driver_ws,
                  _INR(0, 2) | _INR(8, 9),
                  device->device_id, flags, block,
                  entry, device->driver_ref);
}

/*******************************************************************
 Function:      device_miscop
 Description:   Perform miscellaneous operations on the device
 Parameters:    device -> the device
                entry = driver entry to call
                r -> registers for operation
 Returns:       pointer to an error block if failed
                NULL if successful
 ******************************************************************/
_kernel_oserror * device_miscop(device_t *device, unsigned int entry, _kernel_swi_regs *r)
{
    // printf("device_miscop %d. dev id=%d r0=%d\n", entry, device->device_id, r->r[0]);
    return _callx(device->driver_code, device->driver_ws,
                  _INR(0, 9) | _OUTR(0, 7),
                  r->r[0], r->r[1], r->r[2], r->r[3],
                  r->r[4], r->r[5], r->r[6], r->r[7],
                  entry, device->driver_ref,
                  &r->r[0], &r->r[1], &r->r[2], &r->r[3],
                  &r->r[4], &r->r[5], &r->r[6], &r->r[7]
                  );
}
