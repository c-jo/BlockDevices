/*******************************************************************
 * File:        devices
 * Purpose:     Management of block devices
 * Author:      Chris Johns
 ******************************************************************/

#include <stdlib.h>
#include "kernel.h"

#include "devices.h"
#include <stdio.h>

#include "swis.h"

#include "DebugLib/DebugLib.h"

#include "BlockDevicesHdr.h"

#define UNUSED(x) (void)x;

static device_t* devices = 0;

static int next_id = 1;

static struct notify_list_s {
    device_t* device;
    struct  notify_list_s *next;
} *notify_list = 0;

/*******************************************************************
 Function:      devices_notify_announce
 Description:   Announce the starting, or dying, of a device
 Parameters:    device-> the device to announce
                started = 1 if started; 0 if dying
 Returns:       none
 ******************************************************************/
static void device_notify_announce(device_t *device, int started)
{
  dprintf(("", "announcing device %lu %s %p\n",
               device->id,
               started ? "STARTED" : "STOPPED",
               (void*)&(device->info)));

  _swix(OS_ServiceCall, _INR(0,2),
                          device->id,
                          started ? Service_BlockDevices_DeviceAdded
                                  : Service_BlockDevices_DeviceRemoved,
                          &device->info);
}

/*******************************************************************
 Function:      AnnounceCallback_Handler
 Description:   Handler for the announce callback
 ******************************************************************/
_kernel_oserror *AnnounceCallback_Handler(_kernel_swi_regs *r, void *pw)
{
  UNUSED(r);
  dprintf(("", "announce callback handler\n"));

  if (notify_list) {
    int irqs_disabled = _kernel_irqs_disabled();
    struct notify_list_s *item = 0;
    if (!irqs_disabled) _kernel_irqs_off();
    item = notify_list;
    notify_list = notify_list->next;
    if (!irqs_disabled) _kernel_irqs_on();

    // Notify and free
    device_notify_announce(item->device, 1);
    free(item);

    // Add a callback for the next item
    _swix(OS_AddCallBack, _INR(0,1), AnnounceCallback_Entry, pw);
  }

  return NULL;
}

/*******************************************************************
 Function:      devices_init
 Description:   Initialise the block devices system
 Parameters:    none
 Returns:       0 if successful; 1 if failed
 ******************************************************************/
int devices_init(void)
{
    next_id = 1;
    devices = NULL;

    return 0;
}

/*******************************************************************
 Function:      devices_final
 Description:   Finalise the devices system
 Parameters:    none
 Returns:       0 if successful; 1 if failed
 ******************************************************************/
int devices_final(void)
{
    device_t *device = devices;

    while (device)
    {
        device_t *next = device->next;
        device_notify_announce(device, 0);
        device_destroy(device);
        device = next;
    }

    return 0;
}

/*******************************************************************
 Function:      devices_register
 Description:   Register a device with the system
 Parameters:    device-> the device that we're registering
 Returns:       0 if successful; 1 if failed
 ******************************************************************/
int devices_register(device_t *device, void *pw)
{
    int irqs_disabled;
    struct notify_list_s *item = 0;

    irqs_disabled = _kernel_irqs_disabled();
    if (!irqs_disabled) _kernel_irqs_off();
    device->id = next_id++;
    if (!irqs_disabled) _kernel_irqs_on();

    dprintf(("", "registering device '%s' as device %lu [code:%p ws:%p ref:%p]\n",
                 device->info.description, device->id,
                 device->driver_code, device->driver_ws, device->driver_ref));

    irqs_disabled = _kernel_irqs_disabled();
    if (!irqs_disabled) _kernel_irqs_off();
    /* FIXME: If we've wrapped, this is not sufficient; we need to find a gap.
     *        this case is unlikely so I don't care for now.
     */
    device->next = NULL;

    /* Attach to the end of the devices list */
    if (devices == NULL)
    {
        devices = device;
    }
    else
    {
        device_t *last = devices;
        while (last->next != 0) last = last->next;
        last->next = device;
    }

    item = malloc(sizeof(struct notify_list_s));
    item->device = device;
    item->next = 0;

    if (notify_list) {
        // Add to the list
        struct notify_list_s *last = notify_list;
        while (last->next) last = last->next;
        last->next = item;
    } else {
        // New list, add the callback
        notify_list = item;
        _swix(OS_AddCallBack, _INR(0,1), AnnounceCallback_Entry, pw);

    }

    if (!irqs_disabled) _kernel_irqs_on();
    return 0;
}

/*******************************************************************
 Function:      devices_deregister
 Description:   Deregister a device from the system
 Parameters:    device-> the device that we're registering
 Returns:       0 if successful; 1 if failed
 ******************************************************************/
int devices_deregister(int device_id)
{
    device_t *cur = devices;
    device_t *last = 0;

    while (cur && cur->id != device_id)
    {
        last = cur;
        cur = cur->next;
    }
    if (cur == NULL)
    {
        /* We reached the end of the list without finding the device - failed */
        return 1;
    }

    if (last == 0) {
        /* We were the first item */
        devices = cur->next;
    }
    else
    {
        /* Remove from the list */
        last->next = cur->next;
    }

    /* Issue service that we have removed a device */
    device_notify_announce(cur, 0);

    /* Finally free the memory */
    device_destroy(cur);
    return 0;
}

/*******************************************************************
 Function:      devices_rescan
 Description:   Announce the device as being removed and then returning
                to cause anything downstream to update itself.
 Parameters:    device_id = the device id to rescan, 0 for all
 Returns:       0 if successful; 1 if failed
 ******************************************************************/
int devices_rescan(int device_id)
{
    device_t *device = devices;
    int rv = 1;

    while (device) {
      if (device->id == device_id) {
        device_notify_announce(device, 0);
        device_notify_announce(device, 1);
        rv = 0;
      }
      device = device->next;
    }

    if (rv == 1 && device_id != 0)
    {
      /* Device was specified, but we didn't find it */
      return 1;
    }

    return 0;
}

/*******************************************************************
 Function:      devices_finddevice
 Description:   Find a device given the device_id
 Parameters:    device_id = device id to find
 Returns:       pointer to the device, if found
                NULL if not found
 ******************************************************************/
device_t *devices_find(int device_id)
{
    device_t *cur;

    for (cur=devices;
         cur && cur->id != device_id;
         cur=cur->next)
        ; /* Search is in the for loop */

    return cur;
}

/*******************************************************************
 Function:      devices_finddevice_after
 Description:   Find a device AFTER a given the device_id
 Parameters:    device_id = device id to find the device after, or 0
                for the first one
 Returns:       pointer to the next device, if found
                NULL if no more devices found
 ******************************************************************/
device_t *devices_after(device_t *device)
{
    unsigned long device_id = device ? device->id : 0;
    device_t *cur;

    for (cur=devices;
         cur;
         cur=cur->next)
    {
        if (device_id == 0)
            break;

        if (cur->id == device_id)
            device_id = 0;
    }

    return cur;
}
