/*******************************************************************
 * File:        commands
 * Purpose:     Implementation of the *Commands
 * Author:      Chris Johns
 ******************************************************************/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "kernel.h"
#include "swis.h"

#include "BlockDevicesHdr.h"
#include "commands.h"
#include "devices.h"

typedef struct idmessages_s {
    int num;
    const char *message;
} idmessages_t;
#define IDMESSAGE_LAST (-1)


static idmessages_t interface_type_names[] = {
    { BlockDevice_InterfaceType_Unknown, "-" },
    { BlockDevice_InterfaceType_FDC, "FDC" },
    { BlockDevice_InterfaceType_ST506, "ST506" },
    { BlockDevice_InterfaceType_IDE, "ATA" },
    { BlockDevice_InterfaceType_SATA, "SATA" },
    { BlockDevice_InterfaceType_SCSI, "SCSI" },
    { BlockDevice_InterfaceType_NVMe, "NVMe" },
    { IDMESSAGE_LAST }
};


static idmessages_t interface_connection_names[] = {
    { BlockDevice_InterfaceConnection_Unknown, "-" },
    { BlockDevice_InterfaceConnection_Motherboard, "M/B" },
    { BlockDevice_InterfaceConnection_Podule, "Podule" },
    { BlockDevice_InterfaceConnection_PCI, "PCI" },
    { BlockDevice_InterfaceConnection_Parallel, "Paralllel" },
    { BlockDevice_InterfaceConnection_Serial, "Serial" },
    { BlockDevice_InterfaceConnection_USB, "USB" },
    { IDMESSAGE_LAST }
};

static idmessages_t media_type_names[] = {
    { BlockDevice_MediaType_Unknown, "-" },
    { BlockDevice_MediaType_Floppy, "Floppy" },
    { BlockDevice_MediaType_HardDisc, "HardDisc" },
    { BlockDevice_MediaType_SSD, "SSD" },
    { BlockDevice_MediaType_RAM, "RAM" },
    { BlockDevice_MediaType_CD, "CD" },
    { BlockDevice_MediaType_DVD, "DVD" },
    { BlockDevice_MediaType_BluRay, "BD" },
    { IDMESSAGE_LAST }
};

static idmessages_t partition_scheme_names[] = {
    { BlockDevice_PartitionType_MBR, "MBR" },
    { BlockDevice_PartitionType_GPT, "GPT" },
//    { BlockDevices_PartitionType_FileCore, "FileCore" },
    { IDMESSAGE_LAST }
};


/*******************************************************************
 Function:      format_capacity
 Description:   Formats a capacity string
 Parameters:    block_count, block_size = number and size of blocks
                buffer -> where to put the resulting string.
 Returns:       None
 ******************************************************************/
static char *unit_names[] = { "B", "KB", "MB", "GB", "TB" };

static void format_capacity(UINT64 block_count, unsigned block_size, char *buffer)
{
    unsigned long count, units = 0;
    double value;
//    LL_L2UI(count, block_count);
    value = block_count;
    value = value * block_size;

    while (value > 9999 && units < 5) {
      value = value / 1024.0;
      units += 1;
    }

    sprintf(buffer, "%0.1f %s", value, unit_names[units]);
}

/*******************************************************************
 Function:      lookup
 Description:   Look up a descriptions in a table.
 Parameters:    num = number to lookup
                msgs-> the table of messages (idmessages_t list)
 Returns:       pointer to the message, or def if no value found.
 ******************************************************************/
const char *lookup(int num, idmessages_t *msgs)
{
  /* FIXME: Internationalising these message lookups
     could be done here if we cared */

    while (msgs->num != IDMESSAGE_LAST)
    {
        if (msgs->num == num) {
          return msgs->message;
        }
        msgs++;
    }
    return "Unknown";
}

/*******************************************************************
 Function:      find_max_device_depth
 Description:   Find the maximum depth of devices in the tree
 Parameters:    device = device to check (or NULL for root level)
                current_depth = current depth level
 Returns:       Maximum depth found
 ******************************************************************/
static int find_max_device_depth(device_t *device, int current_depth)
{
    int max_depth = current_depth;
    device_t *child = NULL;
    unsigned parent_id = (device == NULL) ? 0 : device->device_id;

    // Find all children of this device (or root devices if device is NULL)
    for (child = 0; (child = devices_after(child)) != NULL; )
    {
        if (child->info.parent_device == parent_id)
        {
            int child_depth = find_max_device_depth(child, current_depth + 1);
            if (child_depth > max_depth)
                max_depth = child_depth;
        }
    }

    return max_depth;
}

/*******************************************************************
 Function:      display_device_and_children
 Description:   Display a device and its children recursively
 Parameters:    device = device to display
                indent = indentation level (number of spaces)
 Returns:       None
 ******************************************************************/
static void display_device_and_children(device_t *device, int indent)
{
    char capacity[16];
    char indent_str[64];
    int i;

    // Create indentation string
    for (i = 0; i < indent && i < 63; i++)
        indent_str[i] = ' ';
    indent_str[i] = '\0';

    format_capacity(device->info.block_count, device->info.block_size, capacity);

    printf("%s%-4i %s %-24s %-8s %-5s %-5s\n",
           indent_str,
           (int)device->device_id,
           device->info.name,
           device->info.description,
           capacity,
           lookup(device->info.interface_type, interface_type_names),
           lookup(device->info.media_type, media_type_names)
           );

    // Display children
    device_t *child = NULL;
    for (child = 0; (child = devices_after(child)) != NULL; )
    {
        if (child->info.parent_device == device->device_id)
        {
            display_device_and_children(child, indent + 2);
        }
    }
}

/*******************************************************************
 Function:      Cmd_BlockDevices
 Description:   Display information about the devices
 Parameters:    none
 Returns:       pointer to an error block if failed
                NULL if successful
 ******************************************************************/
_kernel_oserror *Cmd_BlockDevices(void)
{
    device_t *device = NULL;
    int max_depth = find_max_device_depth(NULL, 0);
    int header_padding = max_depth * 2; // 2 spaces per level
    char padding_str[64];
    int i;

    // Create padding string for header
    for (i = 0; i < header_padding && i < 63; i++)
        padding_str[i] = ' ';
    padding_str[i] = '\0';

    printf("%-4s%s %-24s %-8s %-5s %-5s\n",
           "Dev.", padding_str, "Description", "Capacity", "IFace", "Media");

    // Display root devices (parent_device = 0) and their children
    for (device = 0; (device=devices_after(device)) != NULL; )
    {
        if (device->info.parent_device == 0)
        {
            display_device_and_children(device, 0);
        }
    }
    return NULL;
}

/*******************************************************************
 Function:      Cmd_BlockDeviceInfo
 Description:   Display information about a device.
 Parameters:
 Returns:       pointer to an error block if failed
                NULL if successful
 ******************************************************************/
_kernel_oserror *Cmd_BlockDeviceInfo(const char *arg_string, int argc)
{
    device_t *device=devices_find(atoi(arg_string));

    if (device == NULL)
    {
        return err_BadDevice;
    }

    char capacity[16];
    format_capacity(device->info.block_count, device->info.block_size, capacity);

    printf("Device %d information:\n", (int)device->device_id);
    printf("  Description: %s\n", device->info.description ? device->info.description : "Unknown");
    printf("  Size:        %llu blocks of %d bytes (%s)\n",
        (unsigned long long)device->info.block_count,
        device->info.block_size,
        capacity);
    printf("  Interface:   %s (%s)\n",
        lookup(device->info.interface_type, interface_type_names),
        lookup(device->info.interface_connection, interface_connection_names));
    printf("  Media type:  %s\n", lookup(device->info.media_type, media_type_names));
    printf("  Parent:      %u\n", device->info.parent_device);

    printf("  Flags:      ");
    if (device->info.flags & DeviceFlag_ReadOnly)
        printf(" ReadOnly");
    if (device->info.flags & DeviceFlag_CanEject)
        printf(" CanEject");
    if (device->info.flags & DeviceFlag_Debug)
        printf(" Debug");
    if (device->info.flags == 0)
        printf(" None");
    printf("\n");

    return NULL;
}
