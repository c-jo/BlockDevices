/*******************************************************************
 * File:        commands
 * Purpose:     Implementation of the *Commands
 * Author:      Chris Johns
 ******************************************************************/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "kernel.h"
#include "swis.h"

#include "BlockDevicesHdr.h"
#include "commands.h"
#include "devices.h"
#include "str.h"

#ifndef PYRO
#include "DebugLib/DebugLib.h"
#else
#define dprintf(X) ;
#endif

#define UNUSED(x) (void)x

typedef struct idmessages_s {
    int num;
    const char *message;
} idmessages_t;
#define IDMESSAGE_LAST (-1)


static idmessages_t interface_type_names[] = {
    { BlockDevice_InterfaceType_Unknown, "-" },
    { BlockDevice_InterfaceType_FDC, "FDC" },
    { BlockDevice_InterfaceType_ST506, "ST506" },
    { BlockDevice_InterfaceType_IDE, "ATA" },
    { BlockDevice_InterfaceType_SATA, "SATA" },
    { BlockDevice_InterfaceType_SCSI, "SCSI" },
    { BlockDevice_InterfaceType_NVMe, "NVMe" },
    { IDMESSAGE_LAST }
};

static idmessages_t connection_type_names[] = {
    { BlockDevice_ConnectionType_Unknown, "-" },
    { BlockDevice_ConnectionType_Motherboard, "M/B" },
    { BlockDevice_ConnectionType_Podule, "Podule" },
    { BlockDevice_ConnectionType_PCI, "PCI" },
    { BlockDevice_ConnectionType_Parallel, "Paralllel" },
    { BlockDevice_ConnectionType_Serial, "Serial" },
    { BlockDevice_ConnectionType_USB, "USB" },
    { IDMESSAGE_LAST }
};

static idmessages_t media_type_names[] = {
    { BlockDevice_MediaType_Unknown, "-" },
    { BlockDevice_MediaType_Floppy, "Floppy" },
    { BlockDevice_MediaType_HardDisc, "HardDisc" },
    { BlockDevice_MediaType_SSD, "SSD" },
    { BlockDevice_MediaType_RAM, "RAM" },
    { BlockDevice_MediaType_CD, "CD" },
    { BlockDevice_MediaType_DVD, "DVD" },
    { BlockDevice_MediaType_BluRay, "BD" },
    { IDMESSAGE_LAST }
};

static idmessages_t device_type_names[] = {
    { BlockDevice_DeviceType_Unknown, "-" },
    { BlockDevice_DeviceType_Controller, "Controller" },
    { BlockDevice_DeviceType_Drive, "Drive" },
    { BlockDevice_DeviceType_Disc, "Disc" },
    { BlockDevice_DeviceType_Partition, "Partition" },
    { BlockDevice_DeviceType_Track, "Track" },
    { IDMESSAGE_LAST }
};

/*******************************************************************
 Function:      format_capacity
 Description:   Formats a capacity string
 Parameters:    block_count, block_size = number and size of blocks
                buffer -> where to put the resulting string.
 Returns:       None
 ******************************************************************/
static char *unit_names[] = { "B", "KB", "MB", "GB", "TB" };

#ifdef PYRO
#define BLOCK_COUNT unsigned
#else
#define BLOCK_COUNT uint64_t
#endif
static void format_capacity(BLOCK_COUNT block_count, unsigned block_size, char *buffer)
{
    unsigned long units = 0;
    double value = block_count;

    if (block_count == 0 || block_size == 0)
    {
      *buffer++ = '-';
      *buffer   = 0;
      return;
    }

    value = value * block_size;

    while (value > 9999 && units < 5) {
      value = value / 1024.0;
      units += 1;
    }

    sprintf(buffer, "%0.1f %s", value, unit_names[units]);
}

static void format_id(unsigned long id, char *buffer, int indent)
{
    int i;
    for (i = 0; i < indent && i < 50; i++)
        *buffer++ = ' ';
    sprintf(buffer, "%d", (int)id);
}


/*******************************************************************
 Function:      lookup
 Description:   Look up a descriptions in a table.
 Parameters:    num = number to lookup
                msgs-> the table of messages (idmessages_t list)
 Returns:       pointer to the message, or def if no value found.
 ******************************************************************/
static const char *lookup(int num, idmessages_t *msgs)
{
  /* FIXME: Internationalising these message lookups
     could be done here if we cared */

    while (msgs->num != IDMESSAGE_LAST)
    {
        if (msgs->num == num) {
          return msgs->message;
        }
        msgs++;
    }
    return "?";
}

/*******************************************************************
 Function:      count_devices
 Description:   Count the total number of devices
 Parameters:    None
 Returns:       Total number of devices
 ******************************************************************/
static int count_devices(void)
{
    device_t *device = NULL;
    int count = 0;

    while ((device = devices_after(device)) != NULL)
    {
        count++;
    }

    return count;
}

/*******************************************************************
 Function:      populate_device_table
 Description:   Populate table with device info recursively
 Parameters:    device = device to add
                indent = indentation level
                table = pointer to table array
                row = pointer to current row index
 Returns:       None
 ******************************************************************/
static void populate_device_table(device_t *device, int indent, char **table, int *row)
{
    char capacity[16];
    char id[64];
    device_t *child = NULL;

    dprintf(("", "populate_device_table(device %ld, row %d)\n", device->id, *row));

    format_id(device->id, id, indent);

#ifdef PYRO
    format_capacity(device->info.block_count.lo, device->info.block_size, capacity);
#else
    format_capacity(device->info.block_count, device->info.block_size, capacity);
#endif
    // Column 0: Device ID with indentation
    table[*row * 8 + 0] = strdup(id);

    // Column 1: Name
    table[*row * 8 + 1] = strdup(device->info.name);

    // Column 2: Description
    table[*row * 8 + 2] = strdup(device->info.description);

    // Column 3: Type
    table[*row * 8 + 3] = strdup(lookup(device->info.device_type, device_type_names));

    // Column 4: Interface
    table[*row * 8 + 4] = strdup(lookup(device->info.interface_type, interface_type_names));

    // Column 5: Connection
    table[*row * 8 + 5] = strdup(lookup(device->info.connection_type, connection_type_names));

    // Column 6: Media
    table[*row * 8 + 6] = strdup(lookup(device->info.media_type, media_type_names));

    // Column 7: Capacity
    table[*row * 8 + 7] = strdup(capacity);

    (*row)++;

    // Process children
    for (child = 0; (child = devices_after(child)) != NULL; )
    {
        if (child->info.parent_device == device->id)
        {
            populate_device_table(child, indent + 2, table, row);
        }
    }
}

/*******************************************************************
 Function:      calculate_column_widths
 Description:   Find the longest string in each column
 Parameters:    table = pointer to table array
                rows = number of rows
                cols = number of columns
                headers = pointer to array of column headers
                widths = pointer to array to store column widths
 Returns:       None
 ******************************************************************/
static void calculate_column_widths(char **table, int rows, int cols, char **headers, int *widths)
{
    int row, col;

    dprintf(("", "Calculating column width\n"));

    // Initialize widths to that of the headers
    for (col = 0; col < cols; col++)
    {
        widths[col] = strlen(headers[col]);
    }

    // Find longest string in each column
    for (row = 0; row < rows; row++)
    {
        for (col = 0; col < cols; col++)
        {
            int len = strlen(table[row * cols + col]);
            if (len > widths[col])
            {
                widths[col] = len;
            }
        }
    }
}

/*******************************************************************
 Function:      Cmd_BlockDevices
 Description:   Display information about the devices
 Parameters:    none
 Returns:       pointer to an error block if failed
                NULL if successful
 ******************************************************************/
_kernel_oserror *Cmd_BlockDevices(void)
{
    device_t *device = NULL;
    int device_count = count_devices();
    int i, row = 0;
    int col_width[8];
    char *header[8] = { "Device", "Name", "Description",
                        "Type", "I/F.", "Con.", "Media", "Capacity" };
    char **table;

    dprintf(("", "Got %d devices\n", device_count));

    // Allocate table: device_count rows x 8 columns
    table = (char **)malloc(device_count * 8 * sizeof(char *));
    if (table == NULL)
    {
        return NULL;
    }

    // Populate table with top level devices
    // (the function will recursively add children)
    for (device = 0; (device=devices_after(device)) != NULL; )
    {
        if (device->info.parent_device == 0)
        {
            populate_device_table(device, 0, table, &row);
        }
    }

    // Calculate column widths
    calculate_column_widths(table, row, 8, header, col_width);

    // Print the header
    printf("%-*s %-*s %-*s %-*s %-*s %-*s %-*s %-*s\n",
           col_width[0], header[0],
           col_width[1], header[1],
           col_width[2], header[2],
           col_width[3], header[3],
           col_width[4], header[4],
           col_width[5], header[5],
           col_width[6], header[6],
           col_width[7], header[7]
           );

    // Print the table
    for (i = 0; i < row; i++)
    {
        printf("%-*s %-*s %-*s %-*s %-*s %-*s %-*s %-*s\n",
               col_width[0], table[i * 8 + 0],
               col_width[1], table[i * 8 + 1],
               col_width[2], table[i * 8 + 2],
               col_width[3], table[i * 8 + 3],
               col_width[4], table[i * 8 + 4],
               col_width[5], table[i * 8 + 5],
               col_width[6], table[i * 8 + 6],
               col_width[7], table[i * 8 + 7]);
    }

    // Free table memory
    for (i = 0; i < device_count * 8; i++)
    {
        free(table[i]);
    }

    free(table);
    return NULL;
}

/*******************************************************************
 Function:      Cmd_BlockDeviceInfo
 Description:   Display information about a device.
 Parameters:
 Returns:       pointer to an error block if failed
                NULL if successful
 ******************************************************************/
_kernel_oserror *Cmd_BlockDeviceInfo(const char *arg_string, int argc)
{
    device_t *device=devices_find(atoi(arg_string));
    char capacity[16];

    UNUSED(argc);

    if (device == NULL)
    {
        return err_BadDevice;
    }

#ifdef PYRO
    format_capacity(device->info.block_count.lo, device->info.block_size, capacity);
#else
    format_capacity(device->info.block_count, device->info.block_size, capacity);
#endif

    printf("Device %d information:\n", (int)device->id);
    printf("  Description: %s\n", device->info.description ? device->info.description : "Unknown");
#ifdef PYRO
    printf("  Size:        %lu blocks of %d bytes (%s)\n",
        device->info.block_count.lo,
        device->info.block_size,
        capacity);
#else
    printf("  Size:        %llu blocks of %d bytes (%s)\n",
        (unsigned long long)device->info.block_count,
        device->info.block_size,
        capacity);
#endif
    printf("  Device type: %s\n",
        lookup(device->info.device_type, device_type_names));
    printf("  Interface:   %s (%s)\n",
        lookup(device->info.interface_type,  interface_type_names ),
        lookup(device->info.connection_type, connection_type_names));
    printf("  Media type:  %s\n",
        lookup(device->info.media_type, media_type_names));
    printf("  Parent:      %u\n", device->info.parent_device);

    printf("  Flags:      ");
    if (device->info.flags & DeviceFlag_ReadOnly)
        printf(" ReadOnly");
    if (device->info.flags & DeviceFlag_CanEject)
        printf(" CanEject");
    if (device->info.flags & DeviceFlag_Debug)
        printf(" Debug");
    if (device->info.flags == 0)
        printf(" None");
    printf("\n");

    return NULL;
}
